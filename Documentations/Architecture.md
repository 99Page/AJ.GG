# Architecture 

## Manager 계층

코어데이터를 사용 여부를 묻는 체크박스를 확인 후 넘기면 Xcode에서 기본 생성되는 코드는 뷰에 작성되어 있다. 서로 다른 뷰에서 `Summoner` 라는 클래스를 가져오고 싶으면 같은 코드를 여러번 작성해야해서 특정 엔티티를 담당하는 계층인 `Manager` 계층을 하나 만들었다. 그리고 ViewModel이 이 Manager를 알도록 담당하게 하였다. 

다른 아키텍처까지 보자면 MVVM에 뷰모델이 API 통신을 위한 `Service` 게층과 코어데이터를 위한 `Manager` 계층에 의존을 하게 되었다. 

## Entity-Model-DTO & View

소환사를 등록하고 싶을 때 매치 정보를 띄워준다. 여기서 보여주는 정보는 Riot의 MATCH-V5에서 제공하는 `MatchDto`다. 홈화면에서는 이미 등록된 소환사의, 저장된 매치 정보를 보여준다. 앞서 말한 매치정보와 뷰는 동일하기때문에 같은 뷰를 재사용하려고 했더니 이 때 사용하는 것은 코어데이터에서 저장된 `Entity` (이하 CDData)이다.

앞으로도 이런 경우가 있을 게 우려되었고 한가지 원칙을 세웠다. 

 * 뷰모델은 모델만 프로퍼티 값으로 갖는다. 뷰는 모델만 프로퍼티 값으로 갖는다. 

즉, API 통신 후 Dto를 Model로 변환하고 코어데이터에서 가져온 엔티티도 모델로 변환한다. 

MatchDTO와, CDMatch는 모두 Match라는 모델로 변경한 후 뷰모델에서 사용하기로 했다. 


## 위의 문제점 

Manager는 엔티티 별로 분리되어 있다. 그리고 뷰모델에서 정보를 요청하면 모델로 변환해서 제공한다. 문제는 DTO는 모델로 변환하기 편리하지만 코어데이터는 아니다. 

코어데이터에서 CDSummoner와 CDMatch는 서로 연관 관계를 갖는다. 내가 어떤 소환사의 정보만 가져오더라도 CDMatch의 정보를 같이 가져올 수 있다. 

반면 현재 아키텍처에서는 SummonerManager에게 소환사 정보를 가져오고, 이 소환사 정보를 이용해서 NSPredicate를 만든 후 MatchManager에게 이를 전달해 매치 정보를 가져와야한다. 

